---
description: Guidelines and best practices for building zod schemas
---

# Zod Schema Guidelines for Study Planner

## Core Principles

### String Handling

- **ALWAYS** use `.trim()` on all string schemas to remove leading/trailing whitespace
- Use descriptive, user-friendly validation error messages that can be displayed in the UI
- Define validation limits in the `VALIDATION_LIMITS` constant object for consistency

### Validation Constants

- Store all validation limits in the `VALIDATION_LIMITS` object in `convex/validation.ts`
- Use descriptive names that indicate the field and limit type (e.g., `USER_NAME_MAX_LENGTH`)
- Reference these constants in error messages for consistency

## Schema Organization Patterns

### Atomic Schemas

- Create individual schemas for each field type (e.g., `userNameSchema`, `subjectNameSchema`)
- Use atomic schemas as building blocks for composite schemas
- Export atomic schemas for reuse across the application

### Composite Schemas

- Build complete object schemas by combining atomic schemas
- Use clear naming: `*Schema` for complete objects, `*FormSchema` for form-specific variants
- Example pattern:

```typescript
export const userSchema = z.object({
  email: userEmailSchema,
  password: userPasswordSchema,
  givenName: userNameSchema,
  familyName: userNameSchema,
})
```

### Form-Specific Schemas

- Create specialized schemas for different forms (e.g., `loginSchema`, `profileFormSchema`)
- Extend base schemas when additional validation is needed
- Use `.refine()` for cross-field validation (e.g., password confirmation)

## Validation Patterns

### String Validation

```typescript
export const nameSchema = z
  .string()
  .trim()
  .min(VALIDATION_LIMITS.MIN_LENGTH, `Minimum ${VALIDATION_LIMITS.MIN_LENGTH} characters`)
  .max(VALIDATION_LIMITS.MAX_LENGTH, `Maximum ${VALIDATION_LIMITS.MAX_LENGTH} characters`)
```

### Email Validation

- Use `z.email('Please enter a valid email address').trim()` for email fields
- For optional emails, use `.optional().or(z.literal(''))` to handle empty strings

### Number Validation

```typescript
export const numberSchema = z
  .number()
  .min(VALIDATION_LIMITS.MIN_VALUE, `Must be at least ${VALIDATION_LIMITS.MIN_VALUE}`)
  .max(VALIDATION_LIMITS.MAX_VALUE, `Must be no more than ${VALIDATION_LIMITS.MAX_VALUE}`)
```

### Enum Validation

- Define enum arrays as `const` with `as const` assertion
- Use descriptive error messages for invalid selections

```typescript
export const statusSchema = z.enum(statusOptions, {
  message: 'Invalid status selected. Please choose from the available options.',
})
```

### Optional Fields

- Use `.optional()` for truly optional fields
- For optional strings that might be empty, use `.optional()` or `.optional().or(z.literal(''))`
- Consider whether `undefined` or empty string is the desired default

## Advanced Validation Patterns

### Password Validation

- Use external validators like `validator.isStrongPassword()` with `.refine()`
- Provide comprehensive error messages explaining requirements

```typescript
export const passwordSchema = z
  .string()
  .trim()
  .min(MIN_LENGTH, `Password must be at least ${MIN_LENGTH} characters long`)
  .refine(validator.isStrongPassword, {
    message: 'Password must contain uppercase, lowercase, number, and special character',
  })
```

### Cross-Field Validation

- Use `.refine()` on object schemas for validation that depends on multiple fields
- Specify the `path` for error targeting in forms

```typescript
export const signupSchema = userSchema
  .extend({
    confirmPassword: z.string().trim(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: 'Passwords do not match.',
    path: ['confirmPassword'],
  })
```

### Business Logic Validation

- Create custom validation functions for complex business rules
- Return consistent error objects: `{ isValid: boolean; error?: string }`
- Example: weight validation that checks totals across multiple records

## Type Safety

### Type Exports

- Export TypeScript types for all schemas using `z.infer<typeof schema>`
- Use consistent naming: `*Data` for inferred types

```typescript
export type UserData = z.infer<typeof userSchema>
export type SubjectData = z.infer<typeof subjectSchema>
```

### Validation Helper Functions

- Create generic validation functions that return consistent formats
- Use the `validateWithSchema()` pattern for backward compatibility

```typescript
export function validateWithSchema<T>(
  schema: z.ZodSchema<T>,
  data: unknown,
): { isValid: false; error?: string } | { isValid: true; data: T }
```

## Error Message Guidelines

### User-Friendly Messages

- Write error messages from the user's perspective
- Avoid technical jargon in user-facing messages
- Include specific limits and requirements in messages
- Use consistent tone and formatting across all error messages

### Message Examples

- ✅ "Subject name must be no more than 75 characters"
- ✅ "Password must be at least 8 characters long"
- ✅ "Please enter a valid email address"
- ❌ "String validation failed"
- ❌ "Invalid input"

## Constants and Enums

### Validation Limits Object

```typescript
export const VALIDATION_LIMITS = {
  USER_NAME_MIN_LENGTH: 2,
  USER_NAME_MAX_LENGTH: 50,
  SUBJECT_NAME_MAX_LENGTH: 75,
  // ... other limits
} as const
```

### Enum Definitions

- Define enum arrays with meaningful names
- Use `as const` for type safety
- Group related enums together

```typescript
export const taskStatus = ['todo', 'doing', 'done'] as const
export const taskPriority = ['none', 'low', 'medium', 'high'] as const
```

## Integration Patterns

### Form Integration

- Use schema validation in form components with react-hook-form
- Leverage zod's error objects for field-specific error display
- Create form-specific schemas when UI requirements differ from data requirements

### Convex Integration

- Use the `validateWithSchema()` helper in Convex functions
- Validate input data before database operations
- Handle validation errors consistently across all mutations

### Partial Updates

- Use `.partial()` for update operations where not all fields are required
- Validate only the fields being updated while maintaining full schema integrity

## Best Practices Summary

1. **Always trim strings** - Use `.trim()` on all string schemas
2. **Centralize constants** - Define limits in `VALIDATION_LIMITS`
3. **User-friendly errors** - Write clear, helpful error messages
4. **Atomic building blocks** - Create reusable field schemas
5. **Type safety** - Export TypeScript types for all schemas
6. **Consistent patterns** - Follow established naming and structure conventions
7. **Business logic** - Implement domain-specific validation rules
8. **Form integration** - Consider UI requirements when designing schemas
