---
description: Convex function and schema patterns
---

# Convex Function and Schema Guidelines for Study Planner

## Function Structure Patterns

### Authentication and Authorization

- ALWAYS use `requireAuth(ctx)` to get the authenticated user ID for user-scoped queries
- Use `requireAuthAndOwnership(ctx, resourceId)` to verify both authentication and resource ownership
- For optional ownership checks, use `requireAuthAndOwnership(ctx, resourceId, { allowNull: true })`
- Import auth helpers from `./authHelpers`

### Function Naming Conventions

- Use descriptive function names that clearly indicate the action:
  - `create*` for creating new resources
  - `get*` for retrieving data
  - `update*` for modifying existing resources
  - `delete*` for removing resources
  - `toggle*` for boolean state changes
  - `add*` for adding items to collections

### Argument Validation

- ALWAYS use field definitions from schema.ts for function arguments
- Example: `args: { name: subjectFields.name, code: subjectFields.code }`
- Use `validateWithSchema()` from `./validation` for complex validation
- Handle validation errors by throwing descriptive error messages

### Return Types

- ALWAYS specify return types using validators:
  - `v.id('tableName')` for single ID returns
  - `v.array(objectSchema)` for arrays
  - `v.union(objectSchema, v.null())` for nullable objects
  - `v.null()` for functions that don't return data

## Schema Organization Patterns

### Field Definitions

- Define reusable field objects for each table (e.g., `userFields`, `subjectFields`)
- Export field definitions as `const` with `as const` assertion
- Use these field objects consistently in both schema and function definitions

### Object Schemas

- Create complete object schemas that include system fields:
  - `_id: v.id('tableName')`
  - `_creationTime: v.number()`
  - Spread the field definitions: `...tableFields`

### Index Naming Convention

- Use descriptive index names that include all fields:
  - `by_user` for single field
  - `by_user_and_archived` for multiple fields
  - `by_assessment` for foreign key relationships

## Query Patterns

### Data Retrieval

- Use `.withIndex()` for efficient queries instead of `.filter()`
- Always specify ordering with `.order('desc')` or `.order('asc')`
- Use `.collect()` to get all results or `.first()` for single results
- For user-scoped data, always filter by `userId`

### Filtering

- Prefer index-based filtering over `.filter()` when possible
- Use `.filter()` only for complex conditions that can't be indexed
- Example pattern for status filtering:

```typescript
let query = ctx.db.query('table').withIndex('by_user', (q) => q.eq('userId', userId))
if (args.status) {
  query = query.filter((q) => q.eq(q.field('status'), args.status))
}
```

## Mutation Patterns

### Data Validation

- Validate all input data using zod schemas before database operations
- Check for business rule violations (e.g., duplicate names, weight limits)
- Throw descriptive error messages for validation failures

### Cascading Deletes

- When deleting parent resources, always clean up related child resources
- Follow the hierarchy: Subject → Assessment → (Grades + Tasks)
- Use proper indexing to efficiently find related records

### Partial Updates

- Use `.partial()` on zod schemas for update operations
- Only validate and update fields that are provided
- Check for conflicts (e.g., duplicate names) when updating

## Table Relationships

### Foreign Key Patterns

- Use `v.id('tableName')` for foreign key fields
- Always create indexes for foreign key relationships
- Example: `assessmentId: v.id('assessments')` with index `by_assessment`

### User Ownership

- Every user-owned table must have `userId: v.id('users')`
- Create compound indexes for user + other fields
- Always verify ownership in mutations

## Common Validation Patterns

### Business Rules

- Implement weight validation for assessments (total ≤ 100%)
- Check for duplicate names within user scope
- Validate date ranges and constraints

### Error Handling

- Use descriptive error messages that can be shown to users
- Validate ownership before performing any operations
- Check for required relationships (e.g., assessment exists before adding grades)

## Function Organization

### File Structure

- Group related functions in single files (e.g., all assessment operations in `assessments.ts`)
- Keep CRUD operations together
- Include specialized queries (e.g., `getUpcoming*`, `getByStatus`)

### Import Patterns

```typescript
import { v } from 'convex/values'
import { mutation, query } from './_generated/server'
import { requireAuth, requireAuthAndOwnership } from './authHelpers'
import { tableFields, tableObject } from './schema'
import { tableSchema, validateWithSchema } from './validation'
```

## Query Examples

### Basic User-Scoped Query

```typescript
export const getItemsByUser = query({
  args: { includeArchived: v.optional(v.boolean()) },
  returns: v.array(itemObject),
  handler: async (ctx, args) => {
    const userId = await requireAuth(ctx)
    return await ctx.db
      .query('items')
      .withIndex('by_user', (q) => q.eq('userId', userId))
      .order('desc')
      .collect()
  },
})
```

### Mutation with Validation

```typescript
export const createItem = mutation({
  args: itemFields,
  returns: v.id('items'),
  handler: async (ctx, args) => {
    const userId = await requireAuth(ctx)
    const validation = validateWithSchema(itemSchema, args)
    if (!validation.isValid) {
      throw new Error(validation.error!)
    }
    return await ctx.db.insert('items', {
      ...validation.data,
      userId,
    })
  },
})
```
